#!/bin/bash
set -e

# --- Usage ---
if [[ "$1" == "--usage" ]]; then
  echo "Regenerates a past response (default: last) based on new instructions."
  exit 0
fi

# Ensure jq is installed
if ! command -v jq &> /dev/null; then
    echo "Error: 'jq' is required for this addon."
    exit 1
fi

# Default index
INDEX="-1"

# If the first arg is a number, treat it as the index
if [[ "$1" =~ ^-?[0-9]+$ ]]; then
    INDEX="$1"
    shift
fi

MODEL_FLAG=""
INSTRUCTION_PARTS=()

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --model)
        MODEL_FLAG="--model $2"
        shift # past argument
        shift # past value
        ;;
        *)
        INSTRUCTION_PARTS+=("$1")
        shift # past argument
        ;;
    esac
done

INSTRUCTION="${INSTRUCTION_PARTS[*]}"

# Validate that we have an instruction
if [ -z "$INSTRUCTION" ]; then
  echo "Error: Missing instruction."
  echo "Usage: aico refine [index] \"<instruction>\" [--model <model>]"
  exit 1
fi

# Get the original response metadata using the new --json flag
ORIG_RESP_JSON=$(aico last "$INDEX" --json 2>/dev/null)
if [ -z "$ORIG_RESP_JSON" ]; then
    echo "Error: Could not retrieve message pair at index $INDEX."
    exit 1
fi

# Extract mode and absolute index from JSON
ORIG_MODE=$(echo "$ORIG_RESP_JSON" | jq -r .assistant.mode)
ORIG_CONTENT=$(echo "$ORIG_RESP_JSON" | jq -r .assistant.content)
ORIG_PROMPT_CONTENT=$(echo "$ORIG_RESP_JSON" | jq -r .user.content)
ABS_INDEX=$(echo "$ORIG_RESP_JSON" | jq -r .pair_index)

# Define System Prompt based on mode
if [ "$ORIG_MODE" == "diff" ]; then
    export SYSTEM_PROMPT="You are a Code Refinement Engine.
Your goal is to regenerate a code patch based on new instructions.

**INPUT DATA:**
- <original_prompt>: The user's original request.
- <previous_draft>: The code you generated previously (which was incorrect or incomplete).
- <critique>: The user's specific instructions on how to fix the draft.

**CRITICAL RULES:**
1. You must output **ONLY** the valid \`SEARCH/REPLACE\` blocks.
2. Do **NOT** include conversational filler (e.g., 'Here is the fixed code').
3. The <critique> **OVERRIDES** any conflicting instructions in the <original_prompt>.
4. Your output will be spliced directly into the history as if it were your first and only response."
else
    export SYSTEM_PROMPT="You are a Content Refinement Engine.
Your goal is to rewrite a previous response to satisfy a critique.

**INPUT DATA:**
- <original_prompt>: The user's original request.
- <previous_draft>: The text you generated previously.
- <critique>: The user's specific instructions on how to change the draft.

**CRITICAL RULES:**
1. You must output **ONLY** the new response content.
2. Do **NOT** include conversational filler (e.g., 'I cannot edit history').
3. Do **NOT** explain what you changed. Just output the result.
4. The <critique> **OVERRIDES** any conflicting instructions in the <original_prompt>.
   - Example: If original prompt was 'Draft a minimal deployment plan' and critique is 'Include rollback steps', you MUST output the full plan **with** rollback steps included.
5. Your output will be spliced directly into the history as if it were your first and only response."
fi

# Ephemeral Execution Setup
SESSION_NAME="refine-$(python3 -c 'import secrets; print(secrets.token_hex(4))')"
export PAYLOAD=$(mktemp)
export PROMPT_FILE=$(mktemp)

cleanup() {
    rm -f "$PAYLOAD" "$PROMPT_FILE"
}
trap cleanup EXIT

# Construct the "Frankenstein" Prompt safely
# We use printf to avoid shell variable expansion on the content
{
  echo "<refinement_task>"
  echo "    <original_prompt>"
  printf '%s\n' "$ORIG_PROMPT_CONTENT"
  echo "    </original_prompt>"
  echo "    <previous_draft>"
  printf '%s\n' "$ORIG_CONTENT"
  echo "    </previous_draft>"
  echo "    <critique>"
  printf '%s\n' "$INSTRUCTION"
  echo "    </critique>"
  echo "    <instruction>"
  echo "    Rewrite the content of <previous_draft> to satisfy the <critique>."
  echo "    Respond to the <original_prompt> directly, but apply the modifications requested."
  echo "    **Output ONLY the final rewritten content.**"
  echo "    </instruction>"
  echo "</refinement_task>"
} > "$PROMPT_FILE"


echo "Refining response at index $ABS_INDEX (Mode: $ORIG_MODE)..."

if [ "$ORIG_MODE" == "diff" ]; then
    CMD="generate-patch"
else
    CMD="ask"
fi

# 1. Execute inside ephemeral fork
# Define the inner logic as a literal string to avoid escaping hell.
# This script will be executed inside the ephemeral session.
REFINE_LOGIC='
set -e

# 1. Rewind history
#    We must use absolute indices for the range (e.g. "5..10") because aico
#    does not support mixed-sign ranges (e.g. "5..-1").
aico undo "${REFINE_INDEX}..${REFINE_LAST_INDEX}" >/dev/null

# 2. Generate
#    Pipes the prompt file to the aico command.
#    We allow REFINE_MODEL_ARGS to word-split naturally (for optional flags).
cat "$REFINE_PROMPT_FILE" | aico "$REFINE_CMD" $REFINE_MODEL_ARGS --system-prompt "$REFINE_SYSTEM_PROMPT" -

# 3. Capture result
aico last --json > "$REFINE_PAYLOAD"
'

# Calculate the absolute end of history for the undo range
LAST_INDEX=$(aico last -1 --json 2>/dev/null | jq -r .pair_index)

# Export all context needed by the inner logic
export REFINE_INDEX="$ABS_INDEX"
export REFINE_LAST_INDEX="$LAST_INDEX"
export REFINE_CMD="$CMD"
export REFINE_MODEL_ARGS="$MODEL_FLAG"
export REFINE_PROMPT_FILE="$PROMPT_FILE"
export REFINE_SYSTEM_PROMPT="$SYSTEM_PROMPT"
export REFINE_PAYLOAD="$PAYLOAD"

# Execute in ephemeral fork
aico session-fork --ephemeral "$SESSION_NAME" -- bash -c "$REFINE_LOGIC"

# 2. Apply to Main Session
if [ -s "$PAYLOAD" ]; then
    NEW_ASST_ID=$(cat "$PAYLOAD" | jq -r .assistant.id)
    ORIG_USER_ID=$(echo "$ORIG_RESP_JSON" | jq -r .user.id)

    if [ "$NEW_ASST_ID" == "null" ] || [ "$ORIG_USER_ID" == "null" ]; then
       echo "Error: IDs could not be resolved. Cannot use surgical history splice."
       exit 1
    fi

    # 1. Undo the old one (soft delete)
    aico undo "$INDEX"

    # 2. Splice the new pair immediately after
    NEXT_INDEX=$((ABS_INDEX + 1))
    aico history-splice "$ORIG_USER_ID" "$NEW_ASST_ID" --at-index "$NEXT_INDEX"

    echo "Refinement complete (Original pair hidden, new pair spliced)."
else
    echo "Refinement failed or returned empty content."
    exit 1
fi
